<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Basic branch setup</title>

</head>
<body>
<h1>Development process of the Accellera SystemC implementation</h1>

<p>v0.9, September 2012</p>

<p><em>An HTML-rendered copy of this document can be found at
 <a href="https://github.com/OSCI-WG/systemc/wiki/development">https://github.com/OSCI-WG/systemc/wiki/development</a>.</em></p>

<p>In this document, the internal development process for Accellera's SystemC
Language Working Group (and TLM Working Group) is described.  This mostly
relates to the development and maintenance procedures for the ASI
proof-of-concept implementation of SystemC (and TLM).  This document
focuses on the technical aspects related to the development of the ASI
SystemC implementation.  Legal and formal procedures are documented at
<a href="http://accellera.org">http://accellera.org</a>.</p>

<hr />

<h2>Repository organization</h2>

<p>The central source code repository of the ASI SystemC implementation is
hosted in two <a href="http://git-scm.com" title="Git version control system">Git</a> repositories at <a href="http://github.com">GitHub</a>.  The
repositories are private to the <code>OSCI-WG</code> organization and can be found at:</p>

<ul>
<li><a href="http://github.com/OSCI-WG/systemc">http://github.com/OSCI-WG/systemc</a>             (core SystemC library)</li>
<li><a href="http://github.com/OSCI-WG/systemc-regressions">http://github.com/OSCI-WG/systemc-regressions</a> (regression test suite)</li>
</ul>


<p>Members of the <code>OSCI-WG</code> organization with the necessary access rights can
clone the repositories via SSH from the locations</p>

<pre><code> git clone -o osci-wg git@github.com:OSCI-WG/systemc.git
 git clone -o osci-wg git@github.com:OSCI-WG/systemc-regressions.git
</code></pre>

<p>respectively.  To obtain access to the repositories and the GitHub
organization in general, LWG members can contact the LWG chairs at
<a href="&#x6d;&#97;&#105;&#108;&#116;&#x6f;&#58;&#x6c;&#119;&#103;&#x2d;&#99;&#x68;&#97;&#x69;&#x72;&#x40;&#x6c;&#105;&#x73;&#116;&#115;&#x2e;&#x61;&#x63;&#99;&#101;&#108;&#x6c;&#x65;&#x72;&#97;&#x2e;&#111;&#114;&#x67;">&#x6c;&#x77;&#103;&#x2d;&#x63;&#x68;&#x61;&#x69;&#114;&#x40;&#108;&#x69;&#115;&#x74;&#115;&#46;&#x61;&#x63;&#99;&#101;&#x6c;&#108;&#x65;&#114;&#x61;&#46;&#x6f;&#x72;&#103;</a> including their GitHub account name.</p>

<blockquote><p> <em>Note:</em>
 Using an explicit name of the 'remote' (<code>-o osci-wg</code>) is recommended
 to allow using the default remote name <code>origin</code> for a personal fork
 where you can push your changes by default, see <a href="#sec:branching">below</a>.</p></blockquote>

<p>Comprehensive documentation about <a href="http://git-scm.com" title="Git version control system">Git</a>, a distributed version control
system, can be found in the <a href="http://git-scm.com/book" title="Pro Git Book">Pro Git book</a>, also available online.
Since Git is 'distributed', it is a very natural choice for the distributed
development process needed for the collaboratively evolving proof-of-concept
implementation of SystemC.</p>

<p>In order to contribute changes to the different repositories, it is
recommended to create personal (or company-based) <a href="https://help.github.com/articles/fork-a-repo">forks</a> of the
repositories on GitHub and push the proposed changes (bugfixes,
features, ...) there.  These forks are also only accessible to members
of the OSCI-WG organization. Details of the intended work-flow are
described in the next <a href="#sec:branching">section</a>. It is convenient to
add this GitHub fork as a remote to your local clone of the
repository:</p>

<pre><code>  cd &lt;repo&gt;/
  git remote add origin git@github.com:&lt;your-account&gt;/&lt;repo&gt;.git
  git branch --set-upstream master origin/master
</code></pre>

<p>Any changes can then be pushed to GitHub using:</p>

<pre><code>  git push [options] [&lt;repository&gt;] [&lt;refspec&gt;...]
</code></pre>

<ul>
<li>If you omit the <code>&lt;repository&gt;</code>, the default destination is
the remote of the current branch (or <code>origin</code>).</li>
<li>The <code>&lt;refspec&gt;</code> basically follows the format
 <code>&lt;local-branch&gt;:&lt;remote-branch&gt;</code>, or just <code>&lt;branch&gt;</code>, if
both are the same.</li>
<li>Omitting the <code>&lt;refspec&gt;</code> pushes all branches with 'matching'
remote branches to the repository.</li>
</ul>


<p>A basic cheat sheet containing the an overview of the general
Git commands and workflow can be found <a href="http://zrusin.blogspot.de/2007/09/git-cheat-sheet.html" title="Git Cheat Sheet">online</a>.</p>

<hr />

<p><a id="sec:branching" /></p>

<h2>Development flow</h2>

<h3>Basic branch setup</h3>

<p>The main idea is to have two main branches, one for the development,
one for the releases.</p>

<ul>
<li><p><strong>master</strong></p>

<p>The latest and greatest <code>HEAD</code> of the LWG development.
This is, were all the new features and fixes go.</p></li>
<li><p><strong>release</strong></p>

<p>This branch is used to create the release tarballs, both
internal and public snapshots.</p></li>
</ul>


<p>For the <strong>regressions</strong>, the <code>release</code> branch is more or less just a pointer
to the latest revision of a snapshot (or release).  It is still useful
to keep a named branching point, in case of required hotfixes.</p>

<p>For the <strong>core library</strong>, the <code>release</code> branch is to be different from the
<code>master</code> branch.  The idea is to fully track the contents of the released
tarball.  This requires the following changes compared to the <code>master</code>
branch:</p>

<ul>
<li>The Automake generated files are added to this tree.</li>
<li>ASI internal files are stripped
(<code>.gitignore</code>, internal documentation, ...).</li>
</ul>


<p>To prepare a release, the <code>master</code> branch would then be merged into the
<code>release</code> branch, the automake files would be updated (if necessary) and
the clean working tree could be used as baseline for the tarball (e.g.,
via <code>git-archive(1)</code>).  Details are described in the next section
<a href="#sec:release">release management</a>.  The history of the (core library)
repostitory could then look like shown in the following graph
(time progresses upwards):</p>

<pre><code>   time  feature   master hotfix release
         branches    |         | |
    ^      |  |
    |                [master]
    |                |           [release]
    ^          ----- o           |
    |         /      |           o - [systemc-2.3.0.1]
    |        /    -- o          /|
    |       /    /   |         o |
    ^      |  o--    …          \|
    |      o  …      | --------- o - [systemc-2.3.0]
    |      |  o      …/          |
    |      o   \---- o -[public] …
    ^       \       \|           |
    |        ------- o           o   (internal snapshot)
    |                …           |
    ^                            o - [systemc-2.2.0]
</code></pre>

<p>It should usually be sufficient to keep the two branches <code>master</code>
and <code>release</code>, and cherry-pick hotfixes for emergency releases
directly on top of the <code>release</code> branch.  For convenience, an
additional <code>public</code> branch could be used to mark the branching
point for the last <code>release</code>.</p>

<p>If more sophisticated version branches are needed, a development
model similar to the well-known <a href="http://nvie.com/posts/a-successful-git-branching-model/" title="'A successful Git branching model' by Vincent Driessen">"successful branching model"</a>
can be deployed.  Not all aspects of this model are expected to
be needed for the ASI SystemC implementation, as we usually
maintain only a single (i.e., the latest) public release of the
kernel.</p>

<p><a id="sec:feature-branch" /></p>

<h3>Adding a feature (set)</h3>

<p>The development of a new contribution in form of a feature or a
complex bug fix is best done in a new feature branch, which is
forked and checked out from the ASI <code>master</code> branch:</p>

<pre><code>  git checkout -b &lt;company&gt;-&lt;feature-xyz&gt; master
</code></pre>

<p>Then code up the new contribution.  Please try to facilitate code
review by other ASI members by logically grouping your changes into
one commit per addressed issue. For the commit messages, please
consider to follow these suggestions:</p>

<blockquote><p> <em>Note:</em> <strong>Commit messages</strong></p>

<p> Though not required, it’s a good idea to begin the commit message with
 a single short (less than 50 character) line summarizing the change,
 followed by a blank line and then a more thorough description. Tools
 that turn commits into email, for example, use the first line on the
 <code>Subject:</code> line and the rest of the commit in the body.</p></blockquote>

<p>During the development of the contribution, the <code>master</code> branch may
receive other commits. In that case, consider rebasing the commits in
your feature branch onto the <code>HEAD</code> of the <code>master</code> branch to keep the
history clean. Once the contribution is ready for review by the
working group, push the feature branch in your fork of the respective
repository on GitHub:</p>

<pre><code>  git push &lt;your-github-fork-remote-name&gt; &lt;company&gt;-&lt;feature-xyz&gt;
</code></pre>

<p>Then, send a [pull request] either manually or via <a href="https://help.github.com/articles/using-pull-requests" title="Using Pull Requests - github:help">GitHub</a> to
initiate the code review by the working group members.  The summary
can be manually generated by</p>

<pre><code>  git request-pull master git@github.com/&lt;account&gt;/&lt;repo&gt;.git \
          &lt;company-feature-xyz&gt;
</code></pre>

<p>to be sent to the LWG reflector.</p>

<p>To review the proposed contributions, one can either browse the
repository at <a href="https://help.github.com/articles/using-pull-requests" title="Using Pull Requests - github:help">GitHub</a>, or add the remote location to a local
clone of the repository</p>

<pre><code>  # add the fork to your set of "remotes"
  git remote add &lt;remote-name&gt; git@github.com/&lt;account&gt;/&lt;repo&gt;.git
  git fetch  &lt;remote-name&gt;

  # examine differences
  git diff master..&lt;remote-name&gt;/&lt;company-feature-xyz&gt;
  git log &lt;remote-name&gt;/&lt;company-feature-xyz&gt;
</code></pre>

<p>After the contribution is accepted, it will be merged into the ASI
<code>master</code> branch by the responsible source code maintainer.  This should
be done with an explicit <em>merge commit</em>, to keep the individual
contributions separated:</p>

<pre><code>  git merge --no-ff --log \
     &lt;remote-name&gt;/&lt;company-feature-xyz&gt;
</code></pre>

<p>Instead of fully merging the contribution, the maintainer may choose
to cherry-pick individual commits or to rebase the feature branch on
an intermittently updated <code>master</code>. He may also request additional
changes to be done by the submitter. In that case, the submitter may
need to merge recent changes to the <code>master</code> branch into his feature
branch before carrying out the requested changes.</p>

<p>After the contribution has been fully merged into <code>master</code>, the
feature branch in the local and Github fork may be deleted.</p>

<pre><code>  git branch -d &lt;company-feature-xyz&gt;      # delete local branch
  git push  origin :&lt;company-feature-xyz&gt;  # delete remote branch
</code></pre>

<h3>Tracking release tarballs</h3>

<p>In order to track the release tarballs (both LWG-internal and public
ones), a tool named <a href="http://joeyh.name/code/pristine-tar/" title="pristine-tar homepage"><code>pristine-tar</code></a> is used.  It enables tracking
archives directly within the repository.</p>

<p>When looking at the branches (e.g., by using <code>gitk --all</code>), you may notice
an additional, separate branch called <code>pristine-tar</code>.  This branch contains
the metadata for the pristine-tar tool.  <code>pristine-tar</code> enables
tracking original archives with minimal overhead, since only small binary
deltas instead of the full tarballs are stored within the repository.</p>

<blockquote><p><em>NOTE</em>: Currently, only Linux and Mac OS X are supported platforms for
        <code>pristine-tar</code>.  Porting to Windows (MinGW) is to be done in the
        future, which should be possible with reasonable effort to
        support the required use cases within the ASI SystemC working
        groups.</p></blockquote>

<h4>Basic workflow</h4>

<pre><code>  # adding an archive (done by the maintainer)
  pristine-tar [-m message] commit systemc-2.3.1.tgz release
  git push origin pristine-tar

  # retrieving an archive
  pristine-tar checkout systemc-2.3.0.tgz
</code></pre>

<p>The maintenance of the <code>pristine-tar</code> branch (i.e., adding new archives to
the <code>pristine-tar</code> branch) is done by the LWG chairs during the <a href="#sec:release">release
management</a>.</p>

<h3>Maintaining a private (set of) branches</h3>

<p><em>TODO</em>: Outline maintenance of an in-house forking model, seamlessly
        integrated with the LWG's flow.</p>

<p>Vendor's may be interested in maintaining their own, in-house flow
to align the internal development of a derived SystemC implementation,
while being able to pick fixes from the ASI tree (and hopefully)
contributing fixes and features back to the proof-of-concept
implementation.</p>

<p>For this purpose members may employ the already mentioned <a href="http://zrusin.blogspot.de/2007/09/git-cheat-sheet.html" title="Git Cheat Sheet">"successful
branching model"</a> by Vincent Driessen. The vendor can branch its
own development branch, e.g., <code>develop-&lt;vendor&gt;</code> from the already
tracked ASI's development branch <code>master</code> in his clone of the ASI
repository. The vendor is then able to integrate commits on the ASI
development branch by merging it into his his vendor development
branch.</p>

<p>Bug fixes to be contributed back to ASI consist usually of one or
several isolated commits. They need to be cherry picked from the
vendor's development branch into a new branch created from the ASI
development branch:</p>

<pre><code>  git checkout -b &lt;vendor&gt;-fix-&lt;bug&gt; origin/master
  git cherry-pick &lt;commit&gt;...
</code></pre>

<p>Once, the bug fix branch is ready, it should be pushed into the
vendor's github account and a pull request created, as described in
the <a href="#sec:feature-branch">feature branch section</a>.</p>

<p>A new feature consists usually of a series of commits developed in a
dedicated feature branched of the vendor's or ASI's development
branch. Only in the first case, a rebase on the top of the ASI's
development branch is necessary. To this end, branch first from the
feature branch:</p>

<pre><code>  git checkout -b &lt;vendor&gt;-&lt;new-feature&gt; &lt;private-feature-branch&gt;
  git rebase [-i|--interactive] --onto origin/master develop-&lt;vendor&gt;
</code></pre>

<p>Once, the bug fix branch is ready, it should be pushed into the
vendor's github account and a pull request created, as described in
the <a href="#sec:feature-branch">feature branch section</a>.</p>

<hr />

<p><a id="sec:release" /></p>

<h2>Release management</h2>

<p>To prepare a new release tarball, the following set steps are to be
performed by the maintainer</p>

<ol>
<li><strong>Prepare the release in the <code>master</code> branch</strong></li>
</ol>


<p>  Before creating a release snapshot, the documentation and version
  information in the package should be updated within the <code>master</code>
  branch.  This includes files like
  - <code>ChangeLog</code>, <code>RELEASENOTES</code>, <code>README</code>, <code>INSTALL</code>
  - <code>src/sysc/kernel/sc_ver.h</code>,
    <code>src/tlm_core/tlm_version.h</code></p>

<p>  During the release preparation phase, other functional changes
  should not be added/merged to the <code>master</code> branch.</p>

<ol>
<li><p><strong>Update the <code>release</code> branch</strong></p>

<pre><code> # switch to release branch
 git checkout release

 # merge master branch
 git merge --no-commit master
 git rm &lt;new-internal-file...&gt; # drop new or changed "private" files
 git commit -m "merge master branch for x.x.x release"
</code></pre></li>
<li><p><strong>Update the Autoconf (and other auto-generated) files</strong></p>

<pre><code> autoreconf -if # or config/bootstrap
 git add -u     # add changed files
 git status     # check for untracked files
 git add &lt;new files to distribute&gt;
 git commit -m "update autogenerated files for x.x.x release"
</code></pre></li>
<li><p><strong>Tag the release revision</strong></p></li>
</ol>


<p>  In order to keep track of the release snapshots, the revisions used
  for creating the release tarballs should be marked with an <em>annotated</em>
  and optionally signed Git tag.</p>

<pre><code>    # git tag -a -m "&lt;package&gt; &lt;version&gt;" &lt;package&gt;-&lt;version&gt; &lt;refspec&gt;
    git tag -a -m "SystemC 2.3.0" systemc-2.3.0 release
</code></pre>

<p>  The tag name follow the pattern <code>&lt;package&gt;-&lt;version&gt;</code>, where <code>version</code>
  follows the versioning rules in IEEE 1666-2011, which means it should
  follow one of the three standard formats:
  * <code>x.x.x_beta_&lt;isodate&gt;</code> for beta/internal versions
  * <code>x.x.x_pub_rev_&lt;isodate&gt;</code> for public review versions, and
  * <code>x.x.x</code> for public release versions.</p>

<p>  <em>NOTE:</em> The tag should be on the <code>release</code> branch, to enable the
  automated tarball creation in the next step.</p>

<ol>
<li><strong>Create the release tarball</strong></li>
</ol>


<p>  <code>git archive</code> can then be used to create the release tarball.
  <code>git describe</code> can be used to obtain the correct tarball name
  based on the current tag.</p>

<pre><code>    VERSION="`git describe release`" \
      git archive --format=tar.gz --prefix=${VERSION}/ release \
        &gt; ${VERSION}.tar.gz
</code></pre>

<p>  <em>NOTE:</em> Even without a tag, a quick-shot release of the
          release branch can be generated this way.</p>

<p>  The resulting archive should then be added to the <code>pristine-tar</code>
  branch to keep track of the release history:</p>

<pre><code>    pristine-tar commit ${VERSION}.tgz release
</code></pre>

<ol>
<li><strong>Publish the release</strong></li>
</ol>


<p>  Upload the archive to the LWG area for internal review and
  push the changes to GitHub.</p>

<pre><code>    git push osci-wg \
           master release pristine-tar \
           &lt;package&gt;-&lt;version&gt;
</code></pre>

<p>  <em>NOTE:</em> The tag needs to be pushed explicitly.</p>

<hr />

<h2>Issue tracking</h2>

<p><em>TODO</em>: add issue tracking details</p>

<ul>
<li>Use GitHub issue tracker</li>
<li>Define tags for severities and categories</li>
<li>Use pull-requests</li>
</ul>


<hr />

<h2>Changelog</h2>

<ul>
<li><p>v0.9 - Initial proposal to the ASI LWG (2012-09-25)</p></li>
<li><p>To be discussed during the October LWG phone conference</p></li>
</ul>


<hr />

<h2>Authors</h2>

<ul>
<li>Philipp A. Hartmann <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#112;&#104;&#x69;&#108;&#x69;&#x70;&#112;&#46;&#104;&#97;&#114;&#116;&#109;&#97;&#110;&#x6e;&#x40;&#x6f;&#102;&#102;&#105;&#x73;&#x2e;&#100;&#101;">&#112;&#104;&#x69;&#x6c;&#x69;&#x70;&#x70;&#x2e;&#104;&#97;&#x72;&#x74;&#109;&#x61;&#110;&#110;&#x40;&#111;&#102;&#102;&#105;&#115;&#x2e;&#100;&#101;</a></li>
<li>Torsten Maehne      <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#84;&#111;&#114;&#x73;&#x74;&#x65;&#x6e;&#x2e;&#x4d;&#97;&#x65;&#x68;&#x6e;&#x65;&#64;&#108;&#x69;&#112;&#54;&#x2e;&#102;&#x72;">&#x54;&#111;&#x72;&#x73;&#x74;&#101;&#110;&#x2e;&#x4d;&#97;&#x65;&#x68;&#110;&#x65;&#64;&#x6c;&#105;&#112;&#x36;&#x2e;&#x66;&#114;</a></li>
</ul>

</body>
</html>